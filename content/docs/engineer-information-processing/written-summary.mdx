---
title: "정보처리기사 필기 개념 정리"
description: "정보처리기사 자격증 취득 과정에서 개념을 정리한 내용입니다."
icon: BookMarked
---

<Callout type="warn">
  비전공자 시점으로 필요한 내용만 부분적으로 작성되어 있습니다.
</Callout>

## C언어

---

### 변수와 자료형

<Callout>
  C언어는 **정적 타입(static type)** 언어다. 그래서 컴파일 시점에서 변수 타입이
  정해져야 하고, 변수 선언할 때 **자료형**을 명시해야 한다.
</Callout>

| 자료형        | 크기 (byte) | 범위                                                   | 설명                  |
| ------------- | ----------- | ------------------------------------------------------ | --------------------- |
| `char`        | 1           | -128 ~ 127                                             | 문자 1개 저장 (ASCII) |
| `short`       | 2           | -32,768 ~ 32,767                                       | 작은 정수             |
| `int`         | 4           | -2,147,483,648 ~ 2,147,483,647                         | 기본 정수형           |
| `long`        | 4 또는 8    | 시스템에 따라 다름                                     | 긴 정수형             |
| `long long`   | 8           | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 아주 큰 정수형        |
| `float`       | 4           | ±1.5 × 10⁻⁴⁵ ~ ±3.4 × 10³⁸                             | 단정도 실수           |
| `double`      | 8           | ±5.0 × 10⁻³²⁴ ~ ±1.7 × 10³⁰⁸                           | 배정도 실수           |
| `long double` | 8 또는 16   | 구현체에 따라 다름                                     | 고정밀 실수           |

<br />

### 명령어

| 명령어/구문 | 설명                                                |
| ----------- | --------------------------------------------------- |
| `printf`    | 표준 출력 함수 (콘솔에 값 출력)                     |
| `scanf`     | 표준 입력 함수 (콘솔로부터 값 입력)                 |
| `sizeof`    | 자료형 또는 변수의 메모리 크기 반환                 |
| `typedef`   | 기존 자료형에 새 이름을 정의                        |
| `struct`    | 여러 변수들을 하나의 사용자 정의 자료형으로 묶음    |
| `enum`      | 열거형 정의, 정수형 상수들의 집합                   |
| `union`     | 공용체 정의, 여러 멤버가 같은 메모리 공간을 공유함  |
| `const`     | 상수 선언, 한 번 초기화 후 값 변경 불가             |
| `static`    | 정적 저장, 변수의 수명 유지 및 지역성 부여          |
| `extern`    | 외부 파일 또는 다른 위치에 정의된 변수 참조         |
| `volatile`  | 최적화 방지 키워드, 값이 예기치 않게 변경될 수 있음 |

<Callout title="scanf 와 &의 상관관계">
  `scanf` 는 입력받은 값을 레지스터에 임시로 저장하고, **변수의 주소를 찾아가**
  입력된 값(레지스터에 저장된 값)을 저장한 뒤 레지스터의 값을 지우는 방식으로
  변수에 값을 저장한다. 즉, **값을 저장하기 위해 변수의 주소가 필요**하기에
  참조연산자인 `&` 를 사용하여 변수의 주소 값을 불러온다.
  
```c
#include<stdio.h>
int main() {
  int a;
  scanf("%d", &a); // 입력받은 값을 `a` 에 저장한다.
  return 0;
}
```

하지만 **변수가 포인터거나 배열인 경우**엔 자체가 주소이므로 `&` 를 안써도 된다.

</Callout>

<br />

### 서식문자

| 서식문자 | 설명                     | 사용 예 (`printf`)    | 대응 자료형       |
| -------- | ------------------------ | --------------------- | ----------------- |
| `%d`     | 10진수 정수 (signed)     | `printf("%d", num);`  | `int`             |
| `%i`     | 10진수 정수 (signed)     | `printf("%i", num);`  | `int`             |
| `%u`     | 10진수 정수 (unsigned)   | `printf("%u", unum);` | `unsigned int`    |
| `%o`     | 8진수 정수               | `printf("%o", num);`  | `unsigned int`    |
| `%x`     | 16진수 (소문자)          | `printf("%x", num);`  | `unsigned int`    |
| `%X`     | 16진수 (대문자)          | `printf("%X", num);`  | `unsigned int`    |
| `%f`     | 실수 (소수점 표기)       | `printf("%f", fnum);` | `float`, `double` |
| `%e`     | 실수 (지수 표기, 소문자) | `printf("%e", fnum);` | `float`, `double` |
| `%E`     | 실수 (지수 표기, 대문자) | `printf("%E", fnum);` | `float`, `double` |
| `%g`     | 자동 선택 (소수/지수)    | `printf("%g", fnum);` | `float`, `double` |
| `%G`     | 자동 선택 (소수/지수)    | `printf("%G", fnum);` | `float`, `double` |
| `%c`     | 문자 1개 출력            | `printf("%c", ch);`   | `char`            |
| `%s`     | 문자열 출력              | `printf("%s", str);`  | `char[]`, `char*` |
| `%p`     | 포인터 주소 출력         | `printf("%p", ptr);`  | 포인터형          |
| `%%`     | `%` 문자 출력            | `printf("%%");`       | 없음              |

<Callout type="warn" title="문자 출력 관련 유의사항">

문자를 서식문자를 활용하여 출력할 때 **정수형인지 문자형인지에 따라 다르게 출력되는 것**에 유의해야 한다. 아래 예시를 참고하자.

```c
#include<stdio.h>
int main() {
  char a = 'A';
  printf("%d\n", a); // 'A'의 아스키 코드 값인 65 출력
  printf("%c\n", a); // 'A' 출력

  printf("%d\n", a+1); // 'A'의 아스키 코드 값인 65에서 1을 더한 65 출력
  printf("%c\n", a+1); // 'A'의 아스키 코드 값인 65에서 1을 더한 값에 해당하는 문자인 'B' 출력
  return 0;
}
```

</Callout>

<br />

### 비트 연산자

| 연산자 | 설명                                        | 예시     |
| ------ | ------------------------------------------- | -------- |
| `&`    | 비트 AND (두 비트가 모두 1이면 1)           | `a & b`  |
| `\|`   | 비트 OR (두 비트 중 하나라도 1이면 1)       | `a \| b` |
| `^`    | 비트 XOR (두 비트가 다르면 1, 같으면 0)     | `a ^ b`  |
| `~`    | 비트 NOT (비트 반전)                        | `~a`     |
| `<<`   | 비트 왼쪽 시프트 (비트를 왼쪽으로 이동)     | `a << 2` |
| `>>`   | 비트 오른쪽 시프트 (비트를 오른쪽으로 이동) | `a >> 2` |

<br />

### 기타 연산자

| 연산자   | 설명                                                | 예시                   |
| -------- | --------------------------------------------------- | ---------------------- |
| `sizeof` | 자료형 또는 변수의 메모리 크기를 바이트 단위로 반환 | `sizeof(int)`          |
| `&`      | 주소 연산자 (변수의 메모리 주소를 반환)             | `&a`                   |
| `*`      | 역참조 연산자 (포인터가 가리키는 값을 참조)         | `*ptr`                 |
| `,`      | 쉼표 연산자 (여러 표현식을 하나의 표현식으로 결합)  | `a = (x = 10, y = 20)` |
| `?:`     | 삼항 연산자 (조건 ? 참일 때 : 거짓일 때)            | `x ? y : z`            |
| `->`     | 구조체 포인터 접근 연산자                           | `ptr->member`          |
| `[]`     | 배열 접근 연산자                                    | `arr[3]`               |
| `()`     | 함수 호출, 연산 우선순위 조정                       | `func(a, b)`           |

<br />

### 증감 연산자

| 연산자 | 설명         | 예시         | 의미                |
| ------ | ------------ | ------------ | ------------------- |
| `++`   | 1 증가시키기 | `++a`, `a++` | 변수 `a`에 1을 더함 |
| `--`   | 1 감소시키기 | `--a`, `a--` | 변수 `a`에서 1을 뺌 |

<Callout title="전치 연산과 후치 연산">
  증감 연산자의 위치에 따라 연산 결과가 달라진다. 아래 예제를 확인해보자.

```c
#include <stdio.h>

int main() {
    int a = 10;
		int b = 15;
		int c = a++ + --b; // a는 후치 연산, b는 전치 연산이기에 (10 + 14 = 24)
    // a = 11, b = 14
		int d = ++a + b--; // a는 후치 연산, b는 후치 연산이기에 (12 + 14 = 26)
    // a = 12, b = 13

		printf("%d\n",a);
		printf("%d\n", b);
		printf("%d\n", c);
		printf("%d", d);
		return 0;
}
```

</Callout>

<br />

### 포인터

<Callout title="포인터 산술 연산">포인터 산술 연산</Callout>

<br />

## 네트워크

---

### OSI 7계층

<Callout title="출제 리스트">
  [2022 3월 기출문제
  63번](/docs/engineer-information-processing/2022-03#63-osi-7계층)
</Callout>

<Callout title="정의">
  **OSI(Open System Interconnection) 7계층**은
  <strong>국제 표준화 기구(ISO)</strong>에서 개발한 **7단계로 구성된 네트워크 통신
  과정**을 의미한다.
</Callout>

| 계층             | 정의                                                                  | 프로토콜                                   | PDU               |
| ---------------- | --------------------------------------------------------------------- | ------------------------------------------ | ----------------- |
| 물리 계층        | 데이터를 전기적 신호로 변환하여 전송하는 역할                         | Coax, Fiber, Hub, Wireless, Repeater       | 비트(Bit)         |
| 데이터 링크 계층 | 네트워크 기기 간 데이터 전송 및 오류 제어를 담당                      | Ethernet, SLIP, PPP, FDDI, HDLC, LAN, Wifi | 프레임(Frame)     |
| 네트워크 계층    | 데이터그램의 경로 설정 및 논리적 주소(IP 주소) 관리                   | IP, IPSec, ICMP, IGMP                      | 패킷(Packet)      |
| 전송 계층        | 발신지와 목적지 간의 데이터 전송 제어 및 오류 복구                    | TCP, UDP, ECN, SCTP, DCCP                  | 세그먼트(Segment) |
| 세션 계층        | 통신 장치 간의 세션 설정, 유지, 동기화                                | NetBIOS, SSH, TLS, Sockets                 | 데이터(Data)      |
| 표현 계층        | 데이터 형식 변환, 암호화, 압축 등 송신자와 수신자 간 데이터 표현 관리 | JPG, MPEG, SMB, AFP                        | 데이터(Data)      |
| 응용 계층        | 사용자와 직접 연결되며 응용 소프트웨어를 지원                         | HTTP, DNS, Telnet, FTP                     | 데이터(Data)      |

<br />

### TCP/IP 계층
